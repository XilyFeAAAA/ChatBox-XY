<!-- Generated by SpecStory -->

# Initializing TextMessageEvent with MessageEvent (2025-04-23 13:35:37)

_**User**_

TextMessageEvent我希望init传入一个MessageEvent对象来初始化，怎么写

---

_**Assistant**_

你可以通过修改 `TextMessageEvent` 的 `__init__` 方法，让它接收一个 `MessageEvent` 对象，并将其属性赋值给自身。常见做法有两种：

### 方式一：属性复制
直接在 `__init__` 里把 `MessageEvent` 的属性赋值到 `self` 上：

```python
class TextMessageEvent(MessageEvent):
    def __init__(self, message_event: MessageEvent):
        # 复制所有属性
        self.__dict__.update(message_event.__dict__)
        # 下面可以继续初始化TextMessageEvent特有的属性
        # ... 你的其他初始化代码 ...
```

### 方式二：继承初始化
如果 `MessageEvent` 的 `__init__` 只需要 `data`，你可以这样：

```python
class TextMessageEvent(MessageEvent):
    def __init__(self, message_event: MessageEvent):
        super().__init__(message_event.data)
        # 下面可以继续初始化TextMessageEvent特有的属性
        # ... 你的其他初始化代码 ...
```

### 推荐做法
如果你希望 `TextMessageEvent` 完全基于 `MessageEvent`，推荐用**方式一**，这样所有属性都能继承下来。

---

#### 你可以这样修改你的 `TextMessageEvent`：

```python
class TextMessageEvent(MessageEvent):
    def __init__(self, message_event: MessageEvent):
        self.__dict__.update(message_event.__dict__)
        # 下面可以继续初始化TextMessageEvent特有的属性
        # ... 你的其他初始化代码 ...
```

这样你就可以直接用 `TextMessageEvent(msg_event)` 来初始化了。

如需进一步帮助，请告知！

---

_**User**_

帮我把event的parse改成new方法，如果被忽略就不返回实例，否则正常初始化

---

_**Assistant**_

你可以将 `Event` 类中的 `parse` 方法重命名为 `new`，并调整逻辑如下：

- 如果需要忽略（即命中过滤条件），就返回 `None`。
- 否则，正常返回实例。

下面是修改建议：

```python
class Event(abc.ABC):
    def __init__(self, data):
        self.data: dict = data
        self.time: datetime = datetime.now()
    
    def __str__(self) -> str:
        return f"{self.time}收到GEWE消息"
    
    @classmethod
    def new(cls, raw_data: dict) -> "Event" | None:
        # 忽略5分钟前的历史消息
        if int(raw_data["CreateTime"]) < int(time.time()) - 60 * 5: 
            logging.warning(f"忽略五分钟前的过期消息")
            return None
        # 排除自己发的消息(只能排除私聊，群聊需要分割FromUserName)
        elif raw_data['Wxid'] == raw_data['Data']['FromUserName']['string']:
            return None
        # 排除公众号以及微信团队消息
        elif raw_data['Data']['FromUserName']['string'].startswith('gh_')\
                or raw_data['Data']['FromUserName']['string'].startswith('weixin'):
            return None
        # 排除同步消息
        elif raw_data["Data"]["MsgType"] == MessageType.Sync:
            return None
        
        # 正常返回实例
        return cls(raw_data)
```

**注意事项：**
- 你需要将所有调用 `Event.parse` 的地方改为 `Event.new`。
- 如果子类有重写 `parse`，也要同步改为 `new`。

如需我帮你直接修改文件，请告知！

---

_**User**_

我的意思是__new__可以吗

---

_**Assistant**_

你问的很好，`__new__` 确实可以用来控制实例的创建，并且可以在实例化前决定是否返回实例或 None。  
在 Python 中，`__new__` 是真正负责创建实例的方法（`__init__` 只是初始化），所以你可以在 `__new__` 里做过滤逻辑，如果需要忽略就返回 None，否则正常创建实例。

### 示例代码

```python
class Event(abc.ABC):
    def __new__(cls, raw_data):
        # 忽略5分钟前的历史消息
        if int(raw_data["CreateTime"]) < int(time.time()) - 60 * 5: 
            logging.warning(f"忽略五分钟前的过期消息")
            return None
        # 排除自己发的消息(只能排除私聊，群聊需要分割FromUserName)
        elif raw_data['Wxid'] == raw_data['Data']['FromUserName']['string']:
            return None
        # 排除公众号以及微信团队消息
        elif raw_data['Data']['FromUserName']['string'].startswith('gh_')\
                or raw_data['Data']['FromUserName']['string'].startswith('weixin'):
            return None
        # 排除同步消息
        elif raw_data["Data"]["MsgType"] == MessageType.Sync:
            return None
        # 正常创建实例
        return super().__new__(cls)

    def __init__(self, data):
        self.data: dict = data
        self.time: datetime = datetime.now()
```

### 使用方式

这样你只需要直接用 `Event(raw_data)` 或 `MessageEvent(raw_data)`，如果被过滤就会返回 None，否则返回实例。

### 注意事项

- 如果你有子类（如 `MessageEvent`），子类也会继承这个 `__new__` 行为。
- 这样做会让所有实例化都自动带过滤逻辑，不需要额外的工厂方法。
- 但如果你有特殊需求（比如有的子类不想过滤），需要在子类重写 `__new__`。

---

**总结**：  
你完全可以用 `__new__` 实现你想要的效果，这也是一种比较“Pythonic”的做法。

如需我帮你直接修改文件，请告知！

---

_**User**_

解决

---

_**Assistant**_

你遇到的报错是：

```
RuntimeError: no running event loop
sys:1: RuntimeWarning: coroutine 'Adapter._setup_bot' was never awaited
```

### 问题原因

你在同步环境（如普通脚本或FastAPI启动时）直接调用了 `asyncio.create_task(self._setup_bot())`，但此时没有事件循环在运行，所以会报错。

### 解决方法

#### 1. 在有事件循环的环境下调用

- 如果你是在 FastAPI 项目中，推荐在 `startup` 事件中启动异步任务。

例如：

```python
from fastapi import FastAPI

app = FastAPI()

@app.on_event("startup")
async def startup_event():
    # 这里创建你的 Adapter 实例，并启动异步任务
    adapter = Adapter(Bot())
    await adapter._setup_bot()  # 或者用 asyncio.create_task(adapter._setup_bot())
```

#### 2. 在普通脚本中

如果你在普通脚本（如 main.py）中，需要手动创建事件循环：

```python
import asyncio

if __name__ == "__main__":
    adapter = Adapter(Bot())
    asyncio.run(adapter._setup_bot())
```

#### 3. 不要在 `__init__` 里直接用 `asyncio.create_task`

推荐把异步初始化逻辑放到单独方法里，不要在 `__init__` 里直接调 `asyncio.create_task`，否则容易出现在没有事件循环的环境下被调用。

---

### 总结

- **FastAPI 项目**：用 `@app.on_event("startup")` 注册异步初始化。
- **脚本启动**：用 `asyncio.run()` 包裹你的异步方法。
- **不要在 `__init__` 里直接用 `asyncio.create_task`**。

如需我帮你具体改 Adapter 代码，请贴出相关部分！

---

