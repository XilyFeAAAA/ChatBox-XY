<!-- Generated by SpecStory -->

# 微信消息类设计与实现 (2025-05-04 22:41:35)

_**User**_

我希望写一个Message消息类，对外提供一个classmethod的new方法，这个方法接受接受的微信消息data，然后new会处理data，获取每种消息都有的统一信息，例如发送人，群聊or私聊等等。然后根据消息的具体类型，msg_type=data.get("MsgType)，返回Message的子类，例如TextMessage， VideoMessage等等，然后每个子类里面解析自己独有的参数，例如视频消息要视频链接，文字信息有at对象等等

---

_**Assistant**_

明白你的需求。你想要实现一个消息基类 `Message`，并通过 `classmethod` 的 `new` 方法，根据传入的微信消息 `data`，自动识别消息类型并返回对应的子类（如 `TextMessage`、`VideoMessage` 等）。每个子类负责解析自己特有的字段，而基类负责解析所有消息共有的字段（如发送人、群聊/私聊等）。

下面是一个设计思路和代码示例：

---

### 1. 设计思路

- `Message` 作为基类，负责解析所有消息共有的字段，并提供 `new` 工厂方法。
- `new` 方法根据 `data["MsgType"]` 自动实例化对应的子类。
- 每个子类（如 `TextMessage`、`VideoMessage`）负责解析自己特有的字段。
- 可以用注册表模式，方便扩展新类型。

---

### 2. 代码示例

```python
# src/message.py

class Message:
    _type_registry = {}

    def __init__(self, data):
        self.data = data
        self.sender = data.get("FromUserName")
        self.receiver = data.get("ToUserName")
        self.is_group = self._is_group_message()
        self.msg_type = data.get("MsgType")

    @classmethod
    def register_type(cls, msg_type):
        def decorator(subclass):
            cls._type_registry[msg_type] = subclass
            return subclass
        return decorator

    @classmethod
    def new(cls, data):
        msg_type = data.get("MsgType")
        subclass = cls._type_registry.get(msg_type, cls)
        return subclass(data)

    def _is_group_message(self):
        # 假设群聊ID有特殊前缀，具体规则按实际情况调整
        return "@chatroom" in self.data.get("FromUserName", "")

    def __repr__(self):
        return f"<Message type={self.msg_type} sender={self.sender} group={self.is_group}>"

# 文字消息
@Message.register_type("text")
class TextMessage(Message):
    def __init__(self, data):
        super().__init__(data)
        self.content = data.get("Content")
        self.mentioned = self._parse_mentions()

    def _parse_mentions(self):
        # 解析@对象，具体实现按实际data结构调整
        return []

    def __repr__(self):
        return f"<TextMessage sender={self.sender} content={self.content}>"

# 视频消息
@Message.register_type("video")
class VideoMessage(Message):
    def __init__(self, data):
        super().__init__(data)
        self.video_url = data.get("VideoUrl")
        self.thumb_url = data.get("ThumbUrl")

    def __repr__(self):
        return f"<VideoMessage sender={self.sender} video_url={self.video_url}>"
```

---

### 3. 用法示例

```python
data = {
    "MsgType": "text",
    "FromUserName": "user1",
    "ToUserName": "user2",
    "Content": "你好 @张三",
}
msg = Message.new(data)
print(msg)  # <TextMessage sender=user1 content=你好 @张三>
```

---

你可以根据实际的微信消息结构，调整字段解析和类型注册。这样设计后，扩展新消息类型只需继承 `Message` 并注册即可，主逻辑无需修改。

如需进一步细化某个消息类型的解析逻辑，欢迎补充说明！

---

