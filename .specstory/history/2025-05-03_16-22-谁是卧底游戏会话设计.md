<!-- Generated by SpecStory -->

# 谁是卧底游戏会话设计 (2025-05-04 00:22:31)

_**User**_

根据我的思路帮我设计谁是卧底的gamesession，要求尽量代码简洁美观

---

_**Assistant**_

当然可以！下面是一个简洁美观的“谁是卧底”GameSession类设计思路，结合你的代码和常见的游戏流程，给出如下建议和实现：

---

### 设计思路

1. **属性设计**  
   - chatroom_id: 聊天室唯一标识  
   - max_player_number / min_player_number: 玩家人数上下限  
   - players: 玩家列表  
   - spy/civilian: 卧底词/平民词  
   - spy_player: 卧底玩家  
   - started: 游戏是否已开始

2. **方法设计**  
   - new: 创建新游戏  
   - end: 结束游戏  
   - get: 获取游戏  
   - join: 玩家加入  
   - start: 开始游戏（分配词语和卧底）  
   - is_full: 判断是否满员  
   - is_started: 判断是否已开始

3. **简洁性**  
   - 用@property装饰器简化只读属性  
   - 用类型注解提升可读性  
   - 逻辑清晰，方法职责单一

---

### 推荐实现

```python
import os
import json
import random
from src.model import ChatroomMember
from src.manager import cache

class GameSession:
    sessions = {}

    def __init__(self, chatroom_id: str, max_player_number: int, min_player_number: int):
        self.chatroom_id = chatroom_id
        self.max_player_number = max_player_number
        self.min_player_number = min_player_number
        self.players: list[ChatroomMember] = []
        self.spy: str = ""
        self.civilian: str = ""
        self.spy_player: ChatroomMember | None = None
        self.started: bool = False

    @classmethod
    def new(cls, chatroom_id: str, max_player_number: int, min_player_number: int):
        if chatroom_id in cls.sessions:
            return None
        session = cls(chatroom_id, max_player_number, min_player_number)
        cls.sessions[chatroom_id] = session
        return session

    @classmethod
    def end(cls, chatroom_id: str):
        return cls.sessions.pop(chatroom_id, None)

    @classmethod
    def get(cls, chatroom_id: str):
        return cls.sessions.get(chatroom_id)

    @property
    def is_full(self) -> bool:
        return len(self.players) >= self.max_player_number

    @property
    def is_started(self) -> bool:
        return self.started

    async def join(self, user: ChatroomMember) -> bool:
        if self.is_full or self.started or user in self.players:
            return False
        if cache.chatroom.get_member(user.wxid, self.chatroom_id) is None:
            return False
        self.players.append(user)
        return True

    async def start(self) -> bool:
        if self.started or len(self.players) < self.min_player_number:
            return False
        data_path = os.path.join(os.path.dirname(__file__), 'data.jsonl')
        with open(data_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        item = json.loads(random.choice(lines))
        self.spy = item["spy"]
        self.civilian = item["civilian"]
        self.spy_player = random.choice(self.players)
        self.started = True
        return True
```

---

### 说明

- 这样设计后，GameSession结构清晰，易于扩展和维护。
- 属性和方法职责分明，便于后续添加如投票、淘汰等功能。
- 你可以根据实际需求继续扩展，比如增加游戏状态、投票逻辑等。

如需进一步细化（如增加投票、淘汰、胜负判定等），可随时告知！

---

_**User**_

还需要调用api.send私聊发送身份

---

_**Assistant**_

明白！你需要在 `start` 方法中，给每个玩家私聊发送身份（卧底或平民）。假设你有一个 `api.send` 方法可以私聊消息，下面是推荐的实现方式：

---

### 代码修改建议

1. **修正属性名**  
   你的类里有 `self.players`，但 `join` 和 `start` 方法用的是 `self.player_list`，建议统一为 `self.players`。

2. **私聊发送身份**  
   在 `start` 方法中，遍历所有玩家，判断是否为卧底，然后用 `api.send` 私聊发送身份。

---

### 示例代码

假设 `api.send(wxid, message)` 可以私聊消息：

```python
from src import api
# ... 省略前面代码 ...

    async def start(self):
        """
        1. 抽一个题目
        2. 随机抽一个卧底
        3. 每个人私聊发送身份牌
        4. 开始
        """
        data_path = os.path.join(os.path.dirname(__file__), 'data.jsonl')
        with open(data_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        item = json.loads(random.choice(lines))
        self.spy = item.get("spy")
        self.civilian = item.get("civilian")
        self.spy_player = random.choice(self.players)

        # 给每个玩家私聊发送身份
        for player in self.players:
            if player == self.spy_player:
                word = self.spy
                role = "卧底"
            else:
                word = self.civilian
                role = "平民"
            msg = f"你的身份是【{role}】，词语是：{word}。请不要泄露给其他人！"
            await api.send(player.wxid, msg)
```

---

### 重点说明

- 记得把 `self.player_list` 全部改为 `self.players`，保持一致。
- `api.send` 需要是异步的（即 `await api.send(...)`），否则会阻塞。
- 这样每个玩家都会收到一条私聊消息，内容为自己的身份和词语。

如需进一步完善（如异常处理、发送失败重试等），可随时告知！

---

_**User**_

根据readme，帮我完善vote函数和其他功能

---

_**Assistant**_

<details>
            <summary>Searched codebase "readme" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: src/plugin/_who_is_suspect/readme.md

---

根据 readme 的流程，vote 及相关功能应包含以下要点：

### 主要功能点
1. **投票**：玩家通过@投票，收集所有玩家的投票。
2. **淘汰**：统计票数，淘汰得票最多的玩家，并公布其身份。
3. **胜负判断**：判断游戏是否结束（卧底被淘汰或卧底与平民人数相等）。
4. **轮次推进**：若未结束，进入下一轮，否则公布所有身份和词语。

---

### vote 函数设计思路

- 记录每轮投票（可用字典：`self.votes = {}`，key为被投票wxid，value为票数）。
- 每个玩家只能投一次，且不能投自己。
- 投票结束后，统计票数，淘汰得票最多者。
- 公布淘汰者身份，判断游戏是否结束。
- 若未结束，重置投票，进入下一轮。

---

### 代码实现建议

```python
class GameSession:
    # ... 省略前面代码 ...
    def __init__(self, chatroom_id: str, max_player_number, min_player_number) -> None:
        # ... 省略前面代码 ...
        self.votes: dict[str, set[str]] = {}  # 被投票人wxid: 投票人wxid集合
        self.eliminated: list[ChatroomMember] = []
        self.round: int = 1
        self.ended: bool = False

    async def vote(self, from_wxid, vote_wxid):
        if self.ended:
            await api.send(self.chatroom_id, "游戏已结束，无法投票。")
            return
        # 不能投自己，不能重复投票，不能投已淘汰的人
        if from_wxid == vote_wxid:
            await api.send(self.chatroom_id, "不能投票给自己。")
            return
        if any(from_wxid in voters for voters in self.votes.values()):
            await api.send(self.chatroom_id, "你已经投过票了。")
            return
        voted_player = next((p for p in self.player_list if p.wxid == vote_wxid), None)
        if not voted_player or voted_player in self.eliminated:
            await api.send(self.chatroom_id, "无效的投票对象。")
            return
        # 记录投票
        self.votes.setdefault(vote_wxid, set()).add(from_wxid)
        await api.send(self.chatroom_id, f"{from_wxid} 投票给了 {vote_wxid}")

        # 检查是否所有存活玩家都投票
        alive_players = [p for p in self.player_list if p not in self.eliminated]
        if sum(len(voters) for voters in self.votes.values()) >= len(alive_players):
            await self._end_vote_round()

    async def _end_vote_round(self):
        # 统计票数，找出得票最多者
        max_votes = 0
        eliminated_wxid = None
        for wxid, voters in self.votes.items():
            if len(voters) > max_votes:
                max_votes = len(voters)
                eliminated_wxid = wxid
        eliminated_player = next((p for p in self.player_list if p.wxid == eliminated_wxid), None)
        self.eliminated.append(eliminated_player)
        role = "卧底" if eliminated_player == self.spy_player else "平民"
        await api.send(self.chatroom_id, f"本轮淘汰：{eliminated_player.wxid}，身份：{role}")

        # 判断胜负
        await self._check_game_end()

    async def _check_game_end(self):
        alive_players = [p for p in self.player_list if p not in self.eliminated]
        alive_spy = self.spy_player not in self.eliminated
        alive_civilians = [p for p in alive_players if p != self.spy_player]
        if not alive_spy:
            self.ended = True
            await api.send(self.chatroom_id, "卧底已被淘汰，平民获胜！")
            await self._reveal_all()
        elif len(alive_civilians) <= 1:
            self.ended = True
            await api.send(self.chatroom_id, "卧底获胜！")
            await self._reveal_all()
        else:
            self.votes.clear()
            self.round += 1
            await api.send(self.chatroom_id, f"第{self.round}轮开始，请继续发言并投票。")

    async def _reveal_all(self):
        msg = "游戏结束，身份如下：\n"
        for p in self.player_list:
            role = "卧底" if p == self.spy_player else "平民"
            msg += f"{p.wxid}: {role}\n"
        msg += f"卧底词：{self.spy}，平民词：{self.civilian}"
        await api.send(self.chatroom_id, msg)
```

---

如需进一步细化（如报名、超时、异常处理等），请补充说明！

---

_**User**_

我想写一个player类，里面加入身份，死亡信息，被投票数等，帮我重构

---

_**Assistant**_

非常好的想法！引入 `Player` 类可以让代码结构更清晰，便于扩展和维护。下面是推荐的重构方案：

---

## 1. Player类设计

```python
class Player:
    def __init__(self, member: ChatroomMember):
        self.member = member          # ChatroomMember对象
        self.role = None              # "卧底" 或 "平民"
        self.word = None              # 词语
        self.is_alive = True          # 是否存活
        self.vote_count = 0           # 本轮被投票数

    @property
    def wxid(self):
        return self.member.wxid
```

---

## 2. GameSession重构要点

- `self.player_list` 改为 `self.players: list[Player]`
- 分配身份时直接设置 `Player.role` 和 `Player.word`
- 投票时直接操作 `Player.vote_count` 和 `Player.is_alive`
- 淘汰时设置 `is_alive = False`
- 统计/查找玩家时用 `player.wxid`

---

## 3. 主要方法重构示例

```python
class GameSession:
    # ... 省略其他属性 ...
    def __init__(self, chatroom_id: str, max_player_number, min_player_number) -> None:
        self.chatroom_id = chatroom_id
        self.max_player_number = max_player_number
        self.min_player_number = min_player_number
        self.players: list[Player] = []
        self.spy_word: str = ""
        self.civilian_word: str = ""
        self.round: int = 1
        self.ended: bool = False

    async def join(self, user: ChatroomMember) -> bool:
        if any(p.member == user for p in self.players):
            return False
        if cache.chatroom.get_member(user.wxid, self.chatroom_id) is None:
            return False
        self.players.append(Player(user))
        return True

    async def start(self):
        # ... 抽题目 ...
        spy_player = random.choice(self.players)
        self.spy_word = item.get("spy")
        self.civilian_word = item.get("civilian")
        for player in self.players:
            if player == spy_player:
                player.role = "卧底"
                player.word = self.spy_word
            else:
                player.role = "平民"
                player.word = self.civilian_word
            await api.send(player.wxid, f"你的身份是{player.role},卡片是{player.word}。")
        self.ended = False
        self.round = 1

    async def vote(self, from_wxid, vote_wxid):
        if self.ended:
            await api.send(self.chatroom_id, "游戏已结束，无法投票。")
            return
        voter = next((p for p in self.players if p.wxid == from_wxid and p.is_alive), None)
        voted = next((p for p in self.players if p.wxid == vote_wxid and p.is_alive), None)
        if not voter or not voted or voter == voted:
            await api.send(self.chatroom_id, "无效的投票。")
            return
        if hasattr(voter, 'has_voted') and voter.has_voted:
            await api.send(self.chatroom_id, "你已经投过票了。")
            return
        voted.vote_count += 1
        voter.has_voted = True
        await api.send(self.chatroom_id, f"{from_wxid} 投票给了 {vote_wxid}")

        # 检查是否所有存活玩家都投票
        if all(getattr(p, 'has_voted', False) for p in self.players if p.is_alive):
            await self._end_vote_round()

    async def _end_vote_round(self):
        # 统计票数，找出得票最多者
        max_votes = max(p.vote_count for p in self.players if p.is_alive)
        candidates = [p for p in self.players if p.is_alive and p.vote_count == max_votes]
        eliminated = random.choice(candidates)  # 平票随机淘汰
        eliminated.is_alive = False
        await api.send(self.chatroom_id, f"本轮淘汰：{eliminated.wxid}，身份：{eliminated.role}")
        # 重置投票
        for p in self.players:
            p.vote_count = 0
            if hasattr(p, 'has_voted'):
                del p.has_voted
        await self._check_game_end()

    async def _check_game_end(self):
        alive = [p for p in self.players if p.is_alive]
        alive_spy = [p for p in alive if p.role == "卧底"]
        alive_civilian = [p for p in alive if p.role == "平民"]
        if not alive_spy:
            self.ended = True
            await api.send(self.chatroom_id, "卧底已被淘汰，平民获胜！")
            await self._reveal_all()
        elif len(alive_spy) >= len(alive_civilian):
            self.ended = True
            await api.send(self.chatroom_id, "卧底获胜！")
            await self._reveal_all()
        else:
            self.round += 1
            await api.send(self.chatroom_id, f"第{self.round}轮开始，请继续发言并投票。")

    async def _reveal_all(self):
        msg = "游戏结束，身份如下：\n"
        for p in self.players:
            msg += f"{p.wxid}: {p.role}\n"
        msg += f"卧底词：{self.spy_word}，平民词：{self.civilian_word}"
        await api.send(self.chatroom_id, msg)
```

---

如需完整代码或有特殊需求（如投票超时、报名超时等），请补充说明！

---

_**User**_

为什么这么复杂，不能投票结束后直接判断eliminated的role是不是卧底吗，是的话结束，不是的话判断还剩几人，2人则胜利

---

_**Assistant**_

你的理解完全正确！其实“谁是卧底”核心胜负判定逻辑可以非常简洁：

- 每轮投票淘汰一人，直接判断被淘汰者是否为卧底。
- 如果是卧底，游戏立即结束，平民胜利。
- 如果不是卧底，判断剩余人数，如果只剩2人（卧底+1平民），则卧底胜利。
- 否则进入下一轮。

这样可以大大简化代码和流程。下面给你一个极简的胜负判定逻辑示例：

---

### 极简胜负判定代码片段

```python
async def _end_vote_round(self):
    # 统计票数，找出得票最多者
    max_votes = max(p.vote_count for p in self.players if p.is_alive)
    candidates = [p for p in self.players if p.is_alive and p.vote_count == max_votes]
    eliminated = random.choice(candidates)  # 平票随机淘汰
    eliminated.is_alive = False
    await api.send(self.chatroom_id, f"本轮淘汰：{eliminated.wxid}，身份：{eliminated.role}")

    # 判断胜负
    if eliminated.role == "卧底":
        self.ended = True
        await api.send(self.chatroom_id, "卧底已被淘汰，平民获胜！")
        await self._reveal_all()
        return

    alive = [p for p in self.players if p.is_alive]
    if len(alive) == 2:  # 只剩卧底和一名平民
        self.ended = True
        await api.send(self.chatroom_id, "卧底获胜！")
        await self._reveal_all()
        return

    # 否则进入下一轮
    for p in self.players:
        p.vote_count = 0
        if hasattr(p, 'has_voted'):
            del p.has_voted
    self.round += 1
    await api.send(self.chatroom_id, f"第{self.round}轮开始，请继续发言并投票。")
```

---

### 总结

你的思路是对的，没必要把判定逻辑搞复杂。只要每轮淘汰后判断被淘汰者身份和剩余人数即可，完全可以满足“谁是卧底”的核心玩法。

如需完整极简版代码或有其他需求，欢迎继续提问！

---

_**User**_

游戏结束后应该销毁这个session，下一次重新使用谁是卧底这个命令

---

_**Assistant**_

你的想法非常正确！  
游戏结束后，应该销毁（删除）当前的 `GameSession`，这样下次再用 `/卧底` 命令时会重新创建新的 session，避免数据混乱和资源浪费。

---

### 推荐做法

在游戏结束（即 `_reveal_all` 或胜负判定后），调用 `GameSession.end(chatroom_id)` 方法销毁 session。

#### 代码示例

```python
async def _reveal_all(self):
    msg = "游戏结束，身份如下：\n"
    for p in self.players:
        msg += f"{p.wxid}: {p.role}\n"
    msg += f"卧底词：{self.spy_word}，平民词：{self.civilian_word}"
    await api.send(self.chatroom_id, msg)
    # 游戏结束，销毁session
    GameSession.end(self.chatroom_id)
```

这样，下一次再用 `/卧底` 命令时，会自动创建新的 session，保证每局游戏互不干扰。

---

如需自动重置报名、清理缓存等，也可以在 `end` 方法里扩展。  
如需完整流程代码或有其他细节需求，欢迎继续提问！

---

_**User**_

按照游戏主程序逻辑，帮我完善接口

---

_**Assistant**_

好的，下面我将结合你的主程序（`__init__.py`）的结构，给出“谁是卧底”各接口的标准实现建议，重点完善投票、报名、开始、创建等接口的调用流程，并结合前面建议的 `Player` 类和 `GameSession` 结构。

---

## 1. 创建游戏

```python
@create_matcher.handle()
async def create_game(event: TextMessageEvent):
    chatroom_id = event.chatroom.chatroomId
    if GameSession.get(chatroom_id) is not None:
        return await api.send(chatroom_id, "当前群聊存在开启的游戏")
    GameSession.new(chatroom_id, max_player_number=8, min_player_number=4)  # 可根据需求调整人数
    await api.send(chatroom_id, "谁是卧底开始，发送“加入游戏”报名")
```

---

## 2. 加入游戏

```python
@join_matcher.handle()
async def join_game(event: TextMessageEvent):
    chatroom_id = event.chatroom.chatroomId
    session = GameSession.get(chatroom_id)
    if session is None:
        return await api.send(chatroom_id, "当前群聊暂无开启的游戏")
    if await session.join(event.user):
        await api.send(chatroom_id, f"{event.user.name}成功加入游戏，当前人数{len(session.players)}/{session.max_player_number}")
    else:
        await api.send(chatroom_id, "加入失败，可能已加入或未添加bot为好友")
```

---

## 3. 开始游戏

```python
@start_matcher.handle()
async def start_game(event: TextMessageEvent):
    chatroom_id = event.chatroom.chatroomId
    session = GameSession.get(chatroom_id)
    if session is None:
        return await api.send(chatroom_id, "当前群聊暂无开启的游戏")
    if len(session.players) < session.min_player_number:
        return await api.send(chatroom_id, f"人数不足{session.min_player_number}人，无法开始")
    await session.start()
    await api.send(chatroom_id, "游戏已开始，词语已私聊发送，请大家依次发言后投票")
```

---

## 4. 投票

```python
@vote_matcher.handle()
async def vote(event: TextMessageEvent):
    chatroom_id = event.chatroom.chatroomId
    session = GameSession.get(chatroom_id)
    if session is None:
        return await api.send(chatroom_id, "当前群聊暂无开启的游戏")
    # 假设投票格式为“投票 @某人”，你需要从event中解析被投票人的wxid
    vote_wxid = event.get_at_wxid()  # 伪代码，需根据你的框架实际获取@对象
    from_wxid = event.user.wxid
    if not vote_wxid:
        return await api.send(chatroom_id, "请@你要投票的人")
    await session.vote(from_wxid, vote_wxid)
```

---

## 5. 其他建议

- 游戏结束后，`GameSession.end(chatroom_id)` 自动销毁 session。
- 你可以在 `GameSession` 的 `_reveal_all` 或胜负判定后调用销毁。
- 所有异步方法都要 `await`。

---

## 6. 典型流程举例

1. `/谁是卧底` → 创建游戏
2. `加入游戏` → 玩家报名
3. `开始游戏` → 分配身份并私聊
4. 玩家讨论后 `投票 @某人`
5. 投票结束自动结算，胜负判定，公布身份，销毁session

---

如需具体某一接口的详细实现或有特殊需求，请补充说明！

---

